<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>抠脚男孩儿</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 03 Jul 2018 12:51:21 +0800</pubDate>
    <lastBuildDate>Tue, 03 Jul 2018 12:51:21 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>逻辑回归</title>
        <description>&lt;h2 id=&quot;逻辑回归logic-regression&quot;&gt;逻辑回归（logic regression）&lt;/h2&gt;
&lt;h3 id=&quot;1-理解&quot;&gt;1. 理解&lt;/h3&gt;
&lt;p&gt;logistic回归就是一个线性分类模型，它与线性回归的不同点在于：为了将线性回归输出的很大范围的数，例如从负无穷到正无穷，压缩到0和1之间，这样的输出值表达为“可能性”。这样的话在某些情况会更加合理，也会更有说服力。&lt;/p&gt;
&lt;h5 id=&quot;举例说明一下&quot;&gt;举例说明一下&lt;/h5&gt;
&lt;p&gt;拿肿瘤的大小跟是否是恶性肿瘤的的例子来说。
&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fsuxe7yjtdj30pq03xmxo.jpg&quot; alt=&quot;&quot; /&gt;
根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出 0 或 1，
我们可以预测：
    当 $h_\theta$ 大于等于 0.5 时， 预测 y=1。
    当 $h_\theta$ 小于 0.5 时， 预测 y=0 对于上图所示的数据， 这样的一个线性模型似乎能很好地完成分类任务。假使我们又观测到一个非常大尺寸的恶性肿瘤，将其作为实例加入到我们的训练集中来，这将使得我们获得一条新的直线.
&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fsuxf3q0i0j30j205v3z1.jpg&quot; alt=&quot;&quot; /&gt;
这时，再使用 0.5 作为阀值来预测肿瘤是良性还是恶性便不合适了。可以看出，线性回归模型，因为其预测的值可以超越[0,1]的范围，并不适合解决这样的问题。我们引入一个新的模型， 逻辑回归， 该模型的输出变量范围始终在 0 和 1 之间。 逻辑回归模型的假设是： 
$h_\theta(x)=g(\theta^TX)$
其中：
X 代表特征向量
g 代表逻辑函数（ logistic function）是一个常用的逻辑函数为 S 形函数（ Sigmoid function），公式为：&lt;/p&gt;

&lt;p&gt;$g(z)=\frac{1}{1+e^{-z}}$
该函数的图像为：
&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fsuxfjs04mj30ha07o74h.jpg&quot; alt=&quot;&quot; /&gt;
合起来，我们得到逻辑回归模型的假设：
对模型的理解：$h_\theta(x)=\frac{1}{1+e^{-\theta^TX}}$
$h_\theta(x)$的作用是， 对于给定的输入变量， 根据选择的参数计算输出变量=1 的可能性，即$h_\theta(x)=P(y=1|x;\theta)$&lt;/p&gt;
&lt;h3 id=&quot;2-代码实现&quot;&gt;2. 代码实现&lt;/h3&gt;
&lt;p&gt;数据集：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-0.017612   14.053064  0
-1.395634  4.662541   1
-0.752157  6.538620   0
-1.322371  7.152853   0
0.423363   11.054677  0
0.406704   7.067335   1
0.667394   12.741452  0
-2.460150  6.866805   1
0.569411   9.548755   0
-0.026632  10.427743  0
0.850433   6.920334   1
1.347183   13.175500  0
1.176813   3.167020   1
-1.781871  9.097953   0
-0.566606  5.749003   1
0.931635   1.589505   1
-0.024205  6.151823   1
-0.036453  2.690988   1
-0.196949  0.444165   1
1.014459   5.754399   1
1.985298   3.230619   1
-1.693453  -0.557540  1
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import matplotlib.pyplot as plt
from numpy import *


def loadDataSet():
    dataMat = [];
    labelMat = []
    fr = open('testSet.txt')
    for line in fr.readlines():
        lineArr = line.strip().split()
        dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])])
        labelMat.append(int(lineArr[2]))
    return dataMat, labelMat


def sigmoid(inX):
    return 1.0 / (1 + exp(-inX))


def gradAscent(dataMatIn, classLabels):
    dataMatrix = mat(dataMatIn)  # convert to NumPy matrix
    labelMat = mat(classLabels).transpose()  # convert to NumPy matrix

    m, n = shape(dataMatrix)
    alpha = 0.001
    maxCycles = 500
    weights = ones((n, 1))

    for k in range(maxCycles):  # heavy on matrix operations
        h = sigmoid(dataMatrix * weights)  # matrix mult
        error = (labelMat - h)  # vector subtraction
        weights = weights + alpha * dataMatrix.transpose() * error  # matrix mult
    return weights


def GetResult():
    dataMat, labelMat = loadDataSet()
    weights = gradAscent(dataMat, labelMat)
    print weights
    plotBestFit(weights)


def plotBestFit(weights):
    dataMat, labelMat = loadDataSet()
    dataArr = array(dataMat)
    n = shape(dataArr)[0]
    xcord1 = [];
    ycord1 = []
    xcord2 = [];
    ycord2 = []
    for i in range(n):
        if int(labelMat[i]) == 1:
            xcord1.append(dataArr[i, 1]);
            ycord1.append(dataArr[i, 2])
        else:
            xcord2.append(dataArr[i, 1]);
            ycord2.append(dataArr[i, 2])
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.scatter(xcord1, ycord1, s=30, c='red', marker='s')
    ax.scatter(xcord2, ycord2, s=30, c='green')
    x = arange(-3.0, 3.0, 0.1)
    y = (-(float)(weights[0][0]) - (float)(weights[1][0]) * x) / (float)(weights[2][0])

    ax.plot(x, y)
    plt.xlabel('X1');
    plt.ylabel('X2');
    plt.show()


if __name__ == '__main__':
    GetResult()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;3-运行结果&quot;&gt;3. 运行结果&lt;/h3&gt;
&lt;p&gt;结果，返回了特征值的回归系数。我们的数据集有两个特征值分别是x1，x2。我们又增设了了x0变量。得到的结果
&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fsuxgdf6sjj30bs030wem.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们得出x1和x2的关系（设x0=1），0=4.12414349+0.48007329&lt;em&gt;x1-0.6168482&lt;/em&gt;x2&lt;/p&gt;

&lt;p&gt;画出x1与x2的关系图
&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsuxgn658ej30i80fwdh4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</guid>
        
        <category>机器学习基础</category>
        
        
      </item>
    
      <item>
        <title>线性回归</title>
        <description>&lt;h2 id=&quot;线性回归linear-regression&quot;&gt;线性回归（Linear Regression）&lt;/h2&gt;

&lt;p&gt;在回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析被称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则被称为多元线性回归分析。
回归方程如下:&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n&lt;/script&gt;
所谓的训练也就是利用已知的变量$x_1,x_2,…,x_n$去求$\theta_0,\theta_1,\theta_2,…,\theta_n$。所谓的预测也就是用另一堆变量（$x_1,x_2,…,x_n$）去求$h(\theta)$的值，即预测值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以下面的一元回归分析为例&lt;/strong&gt;
我们想预测特定房子的价值，预测依据是房屋面积。
我们有下面的数据集：
&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsuxiic8hjj305k04njrh.jpg&quot; alt=&quot;&quot; /&gt;
这是一个一元回归模型，预测得到的回归方程为：
$y = 28.77659574x + 1771.80851064$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方程如何得来：&lt;/strong&gt;
也就是对于$\theta$如何求解，是通过损失函数&lt;script type=&quot;math/tex&quot;&gt;J(\theta)=\frac{1}{2}\sum_{i=1}^n {(h_\theta(x^{(i)})-y^{(i)})^2}&lt;/script&gt;
如何调整$\theta$使$J(\theta)$取得最小值有很多方法，其中有最小二乘法和梯度下降法等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最小二乘法：&lt;/strong&gt;
&lt;script type=&quot;math/tex&quot;&gt;\theta=(X^TX)^{-1}X^T\vec{y}&lt;/script&gt;
其中X表示训练特征组成的矩阵，结果表示成$y$向量。但是此方法要求$X$是列满秩的，而且求矩阵比较慢。
&lt;strong&gt;梯度下降法：&lt;/strong&gt;
因为用最小二乘法求$\theta$存在局限性，因此采用下面的梯度下降法求解近似解$\theta$。
由$J(\theta)$公式知道求$\theta^T$转换成了求$J(\theta)$的极小值。
即：
&lt;script type=&quot;math/tex&quot;&gt;\theta_j:=\theta_j-\alpha{\frac{\partial}{\partial\theta_j}J(\theta)}&lt;/script&gt;
其中$\alpha$为学习速率，当$\alpha$过大时，有可能越过最小值；当$\alpha$过小，则可能造成迭代次数过多，收敛速度过慢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是训练上述房屋信息的程序源码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# coding=utf-8
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn import datasets, linear_model


# Function to get data
def get_data(file_name):
    data = pd.read_csv(file_name)  # here ,use pandas to read cvs file.
    X_parameter = []
    Y_parameter = []
    for single_square_feet, single_price_value in zip(data['square_feet'], data['price']):  # 遍历数据，
        X_parameter.append([float(single_square_feet)])  # 存储在相应的list列表中
        Y_parameter.append(float(single_price_value))
    return X_parameter, Y_parameter


def linear_model_main(X_parameters, Y_parameters, predict_value):
    # Create linear regression object
    regr = linear_model.LinearRegression()
    regr.fit(X_parameters, Y_parameters)  # train model
    predict_outcome = regr.predict(predict_value)
    predictions = {}
    predictions['intercept'] = regr.intercept_
    predictions['coefficient'] = regr.coef_
    predictions['predicted_value'] = predict_outcome
    return predictions


X, Y = get_data('linearTest.csv')
predictvalue = 700
result = linear_model_main(X, Y, predictvalue)
print &quot;Intercept value &quot;, result['intercept']
print &quot;coefficient&quot;, result['coefficient']
print &quot;Predicted value: &quot;, result['predicted_value']


# Function to show the resutls of linear fit model
def show_linear_line(X_parameters, Y_parameters):
    # Create linear regression object
    regr = linear_model.LinearRegression()
    regr.fit(X_parameters, Y_parameters)
    plt.scatter(X_parameters, Y_parameters, color='blue')
    plt.plot(X_parameters, regr.predict(X_parameters), color='red', linewidth=4)
    plt.xticks(())
    plt.yticks(())
    plt.show()


show_linear_line(X, Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;
&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsuxiw71nbj30bu03dwep.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsuxj956rwj30i80fwmy0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</guid>
        
        <category>机器学习基础</category>
        
        
      </item>
    
      <item>
        <title>Markdown工具集</title>
        <description>&lt;h3 id=&quot;什么是-markdown&quot;&gt;什么是 Markdown&lt;/h3&gt;

&lt;p&gt;　　Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：如您正在阅读的这篇文章。它使用简单的符号标记不同的标题，分割不同的段落，&lt;strong&gt;粗体&lt;/strong&gt; 或者 &lt;em&gt;斜体&lt;/em&gt; 某些文字.&lt;/p&gt;

&lt;p&gt;　　很多产品的文档也是用markdown编写的，并且以“README.MD”的文件名保存在软件的目录下面。             &lt;br /&gt;
　　&lt;/p&gt;

&lt;h3 id=&quot;一些基本语法&quot;&gt;一些基本语法&lt;/h3&gt;

&lt;p&gt;标题          &lt;br /&gt;
H1 :# Header 1          &lt;br /&gt;
H2 :## Header 2         &lt;br /&gt;
H3 :### Header 3         &lt;br /&gt;
H4 :#### Header 4         &lt;br /&gt;
H5 :##### Header 5          &lt;br /&gt;
H6 :###### Header 6    &lt;br /&gt;
链接 :&lt;a href=&quot;URL&quot;&gt;Title&lt;/a&gt;      &lt;br /&gt;
加粗 :&lt;strong&gt;Bold&lt;/strong&gt;      &lt;br /&gt;
斜体字 :&lt;em&gt;Italics&lt;/em&gt;       &lt;br /&gt;
&lt;em&gt;删除线 :&lt;del&gt;text&lt;/del&gt;        &lt;br /&gt;
段落 : 段落之间空一行         &lt;br /&gt;
换行符 : 一行结束时输入两个空格         &lt;br /&gt;
列表 :&lt;/em&gt; 添加星号成为一个新的列表项。        &lt;br /&gt;
引用 :&amp;gt; 引用内容             &lt;br /&gt;
内嵌代码 : &lt;code class=&quot;highlighter-rouge&quot;&gt;alert('Hello World');&lt;/code&gt;      &lt;br /&gt;
画水平线 (HR) :——–&lt;/p&gt;

&lt;p&gt;css 的大部分语法同样可以在 markdown 上使用，但不同的渲染器渲染出来的 markdown 内容样式也不一样，下面这些链接里面有 markdown 基本语法，你也可以在下面几个平台上尝试着写一些。&lt;/p&gt;

&lt;h3 id=&quot;一些好用的-markdown-编辑器&quot;&gt;一些好用的 Markdown 编辑器&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mahua.jser.me/?utm_source=mindstore.io&quot;&gt;MaHua&lt;/a&gt; 在线 Markdown 编辑器 ,无须测试。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/markdown/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mdp.tylingsoft.com/&quot;&gt;Markdown Plus&lt;/a&gt; 一款 Markdown 编辑器，可以支持添加任务列表、emoji、流程图等。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/markdown/image2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zybuluo.com/cmd/?utm_source=mindstore.io&quot;&gt;Cmd Markdown&lt;/a&gt; 作业部落在线 Markdown 编辑器推出桌面版客户端啦，全平台支援。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/markdown/image3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/MacDownApp/macdown&quot;&gt;Macdown&lt;/a&gt; Github 上开源的 Mac 平台上的 Markdown 编辑器&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gitbook.com/editor?utm_source=mindstore.io&quot;&gt;GitBook Editor&lt;/a&gt; 一款团队在线编辑文档工具。可以轻松书写笔记，支持团队协同编辑。同时支持 Markdown 语法，还保持了印象笔记的风格并可在线预览。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.glamdevelopment.com/outlinely?utm_source=mindstore.io&quot;&gt;Outlinely&lt;/a&gt; 界面简洁大方的大纲类 Mac 软件，使用起来很简单，而且支持输出 Markdown 格式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://classeur.io/?utm_source=mindstore.io&quot;&gt;Classeur&lt;/a&gt; 实用简洁的 Markdown 写作工具，快速上手。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/geekcompany/DeerResume?utm_source=mindstore.io&quot;&gt;DeerResume&lt;/a&gt; 程序员专用 MarkDown 简历制作在线工具。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/11/markdownTool/&quot;&gt;Markdown工具集&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/markdownTool/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/markdownTool/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>层次聚类</title>
        <description>&lt;h1 id=&quot;一层次聚类原理介绍&quot;&gt;一、层次聚类原理介绍&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;1-hierarchical-clustering&quot;&gt;1. Hierarchical clustering&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;聚集法（Agglomerative）：这是一种“自下而上”的方法。将每一个原始数据分成一个cluster，计算这每个cluster之间的“距离”，然后将符合这个“距离”的cluster合并。执行若干次，最终把所有的数据聚到一个cluster中。而聚成什么样的结果，聚成几个类，跟自己设定这个“距离”的阈值而定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分割法（Divisive）：跟上面的方法恰好相反，是一种“自下而上”的方法。因为最终的结果跟上面的一样，但是程序实现的话聚集是比分割容易一些的，因此这个方法很少使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基本步骤(聚集法)：
1). 将每个对象归为一类, 共得到N类, 每类仅包含一个对象. 类与类之间的距离就是它们所包含的对象之间的距离
2). 找到最接近的两个类并合并成一类, 于是总的类数少了一个.
3). 重新计算新的类与所有旧类之间的距离.
4). 重复第2步和第3步, 直到最后合并成一个类为止(此类包含了N个对象).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;层次聚类树如下：
&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fsuwv9wm6xj30bm099aal.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-皮尔逊积矩相关系数pearson-product-moment-correlation-coefficient&quot;&gt;2. 皮尔逊积矩相关系数（Pearson product-moment correlation coefficient）：&lt;/h3&gt;
&lt;p&gt;（维基百科：https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient）
在统计学中，它用于度量两个变量X和Y之间的相关（线性相关），其值介于-1与1之间。在自然科学领域中，该系数广泛用于度量两个变量之间的相关程度。
通常有以下公式计算：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;公式一：
&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fsuwwpj2h7j30ef01f0sx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;公式二：
&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fsuwxj2jqgj308r01kdfw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;公式三：
&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fsuwxz6e8rj306501n74a.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;公式四：
&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsuwym8wwej308f02n0su.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;通常情况下通过以下取值范围判断变量的相关强度：
相关系数     0.8-1.0     极强相关
                 0.6-0.8     强相关
                 0.4-0.6     中等程度相关
                 0.2-0.4     弱相关
                 0.0-0.2     极弱相关或无相关&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上的四个公式是等价的（为啥等价，有待研究），其中第一个公式比较有助于理解，就是用两个样本的协方差除以它们的标准差的积，用它来描述它们的相关性。下面程序实现的话，选择的是容易带入计算的公式四。&lt;/p&gt;

&lt;h1 id=&quot;二代码实现&quot;&gt;二、代码实现&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;1-数据集&quot;&gt;1. 数据集&lt;/h3&gt;
&lt;p&gt;blogdata.txt
数据集选择的是网上已经整理好的数据，即从100篇英文blog中选出了1412个单词。部分数据如下：
&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fsux0qo1bgj30ce07r75b.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中第一列表示每篇blog名，每一行表示每篇blog的词频，把每一行的单词数目当作一个1412维向量进行处理。这样就是100个1412维的数据了，在通过上面介绍的皮尔逊系数去计算它们之间的相关性，并根据相关性把他们分成不同的类。&lt;/p&gt;

&lt;h3 id=&quot;2-源代码&quot;&gt;2. 源代码&lt;/h3&gt;
&lt;p&gt;clusterBase.py&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这个是用来读取数据和计算皮尔逊距离的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from math import sqrt

def importData(FIFE='blogdata.txt'):
    blogwords = []
    blognames = []
    i = 0
    f = open(FIFE, 'r')
    for line in f:
        i += 1
        blog = line.split('\t')
        blognames.append(blog[0])
        if i != 1:
            blogwords.append([int(word_c) for word_c in blog[1:]])
    return blogwords, blognames

def pearson_distance(vector1, vector2):
    &quot;&quot;&quot;
    Calculate distance between two vectors using pearson method
    See more : http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
    &quot;&quot;&quot;
    sum1 = sum(vector1)
    sum2 = sum(vector2)
 
    sum1Sq = sum([pow(v, 2) for v in vector1])
    sum2Sq = sum([pow(v, 2) for v in vector2])
 
    pSum = sum([vector1[i] * vector2[i] for i in range(len(vector1))])
 
    num = pSum - (sum1 * sum2 / len(vector1))
    den = sqrt((sum1Sq - pow(sum1, 2) / len(vector1)) * (sum2Sq - pow(sum2, 2) / len(vector1)))
 
    if den == 0: return 0.0
    return 1.0 - num / den
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;hierachiclaCluster.py&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;主执行程序，产生聚类结果并且将结果画成图&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# coding=utf-8
# /usr/bin/python
from clusterBase import importData, pearson_distance
# 将cluster封装成一个class，vec的类型是一个列表，表示的是每一篇blog的词频，left和right表示的是每个cluster左右相邻的cluster（这个是为
# 了后边画图用的，distance是两个vec之间的皮尔逊距离）
class bicluster:
    def __init__(self, vec, left=None, right=None, distance=0.0, id=None):
        self.left = left
        self.right = right
        self.vec = vec
        self.id = id
        self.distance = distance
 
def hcluster(blogwords, blognames):
    biclusters = [bicluster(vec=blogwords[i], id=i) for i in range(len(blogwords))]
    distances = {}  # 字典类型，key为(vec1,vec2),value为它们的皮尔逊距离
    flag = None;
    currentclusted = -1
    # 每次循环减少一个cluster，直到就剩一个cluster
    while (len(biclusters) &amp;gt; 1):
        min_val = 1;
        biclusters_len = len(biclusters)
        for i in range(biclusters_len - 1):
            for j in range(i + 1, biclusters_len):
                if distances.get((biclusters[i].id, biclusters[j].id)) == None:
                    distances[(biclusters[i].id, biclusters[j].id)] = pearson_distance(biclusters[i].vec,biclusters[j].vec)
                d = distances[(biclusters[i].id, biclusters[j].id)]
                if d &amp;lt; min_val:
                    min_val = d
                    flag = (i, j)
        bic1, bic2 = flag
        # 合并之后的vec为vec1和vec2的均值
        newvec = [(biclusters[bic1].vec[i] + biclusters[bic2].vec[i]) / 2 for i in range(len(biclusters[bic1].vec))]
        newbic = bicluster(newvec, left=biclusters[bic1], right=biclusters[bic2], distance=min_val, id=currentclusted)
        currentclusted -= 1
        del biclusters[bic2]
        del biclusters[bic1]
        biclusters.append(newbic)
    return biclusters[0]
 
'''
Print the tree structure, save as a jpeg image file.
'''
from PIL import Image, ImageDraw
 
def getheight(clust):
    if clust.left == None and clust.right == None: return 1
    return getheight(clust.left) + getheight(clust.right)
 
def getdepth(clust):
    if clust.left == None and clust.right == None: return 0
    return max(getdepth(clust.left), getdepth(clust.right)) + clust.distance
 
def drawdendrogram(clust, labels, jpeg='clusters.jpg'):
    h = getheight(clust) * 20
    w = 1200
    depth = getdepth(clust)
    scaling = float(w - 150) / depth
 
    img = Image.new('RGB', (w, h), (255, 255, 255))
    draw = ImageDraw.Draw(img)
    draw.line((0, h / 2, 10, h / 2), fill=(255, 0, 0))
 
    drawnode(draw, clust, 10, (h / 2), scaling, labels)
    img.save(jpeg, 'JPEG')
  
def drawnode(draw, clust, x, y, scaling, labels):
    if clust.id &amp;lt; 0:
        h1 = getheight(clust.left) * 20
        h2 = getheight(clust.right) * 20
        top = y - (h1 + h2) / 2
        bottom = y + (h1 + h2) / 2
        # line length
        ll = clust.distance * scaling
        draw.line((x, top + h1 / 2, x, bottom - h2 / 2), fill=(255, 0, 0))
        draw.line((x, top + h1 / 2, x + ll, top + h1 / 2), fill=(255, 0, 0))
        draw.line((x, bottom - h2 / 2, x + ll, bottom - h2 / 2), fill=(255, 0, 0))
        drawnode(draw, clust.left, x + ll, top + h1 / 2, scaling, labels)
        drawnode(draw, clust.right, x + ll, bottom - h2 / 2, scaling, labels)
    else:
        draw.text((x + 5, y - 7), labels[clust.id], (0, 0, 0))
 
if __name__ == '__main__':
    # pearson_distance
    blogwords, blognames = importData()
    clust = hcluster(blogwords, blognames)
    print clust
    drawdendrogram(clust, blognames, jpeg='blogclust1.jpg')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;3-运行结果&quot;&gt;3. 运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fsux1h7hroj30xc1j0q9d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;三总结&quot;&gt;三、总结&lt;/h1&gt;
&lt;p&gt;采用层次聚类的方法效果看起来挺不错，但是时间复杂度太大。自底向上的聚集法的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(n^{2}\log(n))&lt;/script&gt;，自顶向下的分割法的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(2^{n})&lt;/script&gt;。层次聚类的算法运算量太大无法运用于大规模数据，所以一般是将层次聚类跟kmeans聚类结合起来使用。
用层次聚类算法得到信息的初始化信息，比如可以分成多少个簇，中心点的位置信息等，这样接下来可以利用这些信息来做Kmens聚类。这样的好处是可以解决Kmeans算法初始中心位置的随机性而且可以减少运算量，同时又避免了运用层次聚类算法的大运算量。&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/</guid>
        
        <category>机器学习基础</category>
        
        
      </item>
    
      <item>
        <title>Jekyll搭建个人博客</title>
        <description>&lt;p&gt;　之前写了一篇&lt;a href=&quot;http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;HEXO搭建个人博客&lt;/a&gt;的教程获得了很好评，尤其是在&lt;a href=&quot;http://www.jianshu.com/p/465830080ea9&quot;&gt;简书&lt;/a&gt;上目前已经累积了10W+的阅读量了，也有好心的读者主动给我打赏，在此感谢。&lt;/p&gt;

&lt;p&gt;　如果你看过我的文章会发现我现在的博客样式跟之前是有很大的区别的，之前我也是使用 HEXO 搭建的博客，后来发现使用 HEXO 在多台电脑上发布博客，操作起来并不是那么方便，果断就转到了 Jekyll 上，接下来我会讲如何使用 Jekyll 搭建博客，&lt;a href=&quot;http://baixin.io/#blog&quot;&gt;博客模板效果&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;

&lt;p&gt;　Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的&lt;/p&gt;

&lt;p&gt;　使用 Jekyll 搭建博客之前要确认下本机环境，Git 环境（用于部署到远端）、&lt;a href=&quot;http://www.ruby-lang.org/en/downloads/&quot;&gt;Ruby&lt;/a&gt; 环境（Jekyll 是基于 Ruby 开发的）、包管理器 &lt;a href=&quot;http://rubygems.org/pages/download&quot;&gt;RubyGems&lt;/a&gt;              &lt;br /&gt;
　　如果你是 Mac 用户，你就需要安装 Xcode 和 Command-Line Tools了。下载方式 Preferences → Downloads → Components。&lt;/p&gt;

&lt;p&gt;　　Jekyll 是一个免费的简单静态网页生成工具，可以配合第三方服务例如： Disqus（评论）、多说(评论) 以及分享 等等扩展功能，Jekyll 可以直接部署在 Github（国外） 或 Coding（国内） 上，可以绑定自己的域名。&lt;a href=&quot;http://jekyll.bootcss.com/&quot;&gt;Jekyll中文文档&lt;/a&gt;、&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll英文文档&lt;/a&gt;、&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;Jekyll主题列表&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;jekyll-环境配置&quot;&gt;Jekyll 环境配置&lt;/h3&gt;

&lt;p&gt;安装 jekyll&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll     
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建博客&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll new myBlog    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入博客目录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd myBlog  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动本地服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在浏览器里输入： &lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;，就可以看到你的博客效果了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/jekyll/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;so easy !&lt;/p&gt;

&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;p&gt;　
　Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是： 你用你最喜欢的标记语言来写文章，可以是 Markdown，也可以是 Textile,或者就是简单的 HTML, 然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置URL路径, 你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。&lt;/p&gt;

&lt;p&gt;一个基本的 Jekyll 网站的目录结构一般是像这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _config.yml
├── _includes
|   ├── footer.html
|   └── header.html
├── _layouts
|   ├── default.html
|   ├── post.html
|   └── page.html
├── _posts
|   └── 2016-10-08-welcome-to-jekyll.markdown
├── _sass
|   ├── _base.scss
|   ├── _layout.scss
|   └── _syntax-highlighting.scss
├── about.md
├── css
|   └── main.scss
├── feed.xml
└── index.html

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些目录结构以及具体的作用可以参考 &lt;a href=&quot;http://jekyll.com.cn/docs/structure/&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;进入 _config.yml 里面，修改成你想看到的信息，重新 jekyll server ，刷新浏览器就可以看到你刚刚修改的信息了。&lt;/p&gt;

&lt;p&gt;到此，博客初步搭建算是完成了，&lt;/p&gt;

&lt;h3 id=&quot;博客部署到远端&quot;&gt;博客部署到远端&lt;/h3&gt;

&lt;p&gt;　我这里讲的是部署到 Github Page 创建一个 github 账号，然后创建一个跟你账户名一样的仓库，如我的 github 账户名叫 &lt;a href=&quot;https://github.com/leopardpan&quot;&gt;leopardpan&lt;/a&gt;，我的 github 仓库名就叫 &lt;a href=&quot;https://github.com/leopardpan/leopardpan.github.io&quot;&gt;leopardpan.github.io&lt;/a&gt;，创建好了之后，把刚才建立的 myBlog 项目 push 到 username.github.io仓库里去（username指的是你的github用户名），检查你远端仓库已经跟你本地 myBlog 同步了，然后你在浏览器里输入 username.github.io ，就可以访问你的博客了。&lt;/p&gt;

&lt;h3 id=&quot;编写文章&quot;&gt;编写文章&lt;/h3&gt;

&lt;p&gt;　　所有的文章都是 _posts 目录下面，文章格式为 mardown 格式，文章文件名可以是 .mardown 或者 .md。&lt;/p&gt;

&lt;p&gt;　　编写一篇新文章很简单，你可以直接从 _posts/ 目录下复制一份出来 &lt;code class=&quot;highlighter-rouge&quot;&gt;2016-10-16-welcome-to-jekyll副本.markdown&lt;/code&gt; ，修改名字为 2016-10-16-article1.markdown ，注意：文章名的格式前面必须为 2016-10-16- ，日期可以修改，但必须为 年-月-日- 格式，后面的 article1 是整个文章的连接 URL，如果文章名为中文，那么文章的连接URL就会变成这样的：http://baixin.io/2015/08/%E6%90%AD%E5/ ， 所以建议文章名最好是英文的或者阿拉伯数字。 双击 2016-10-16-article1.markdown 打开&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
---
layout: post
title:  &quot;Welcome to Jekyll!&quot;
date:   2016-10-16 11:29:08 +0800
categories: jekyll update
---

正文...

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;title: 显示的文章名， 如：title: 我的第一篇文章                  &lt;br /&gt;
date:  显示的文章发布日期，如：date: 2016-10-16                        &lt;br /&gt;
categories: tag标签的分类，如：categories: 随笔&lt;/p&gt;

&lt;p&gt;注意：文章头部格式必须为上面的，…. 就是文章的正文内容。&lt;/p&gt;

&lt;p&gt;我写文章使用的是 Sublime Text2 编辑器，如果你对 markdown 语法不熟悉的话，可以看看&lt;a href=&quot;https://www.zybuluo.com/&quot;&gt;作业部落的教程&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用我的博客模板&quot;&gt;使用我的博客模板&lt;/h3&gt;

&lt;p&gt;虽然博客部署完成了，你会发现博客太简单不是你想要的，如果你喜欢我的模板的话，可以使用我的模板。&lt;/p&gt;

&lt;p&gt;首先你要获取的我博客，&lt;a href=&quot;https://github.com/leopardpan/leopardpan.github.io.git&quot;&gt;Github项目地址&lt;/a&gt;，你可以直接&lt;a href=&quot;https://github.com/leopardpan/leopardpan.github.io/archive/master.zip&quot;&gt;点击下载博客&lt;/a&gt;，进去leopardpan.github.io/ 目录下， 使用命令部署本地服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll server   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;如果你本机没配置过任何jekyll的环境可能会报错&quot;&gt;如果你本机没配置过任何jekyll的环境，可能会报错&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Users/xxxxxxxx/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require': cannot load such file -- bundler (LoadError)
	from /Users/xxxxxxxx/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/gems/jekyll-3.3.0/lib/jekyll/plugin_manager.rb:34:in `require_from_bundler'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/gems/jekyll-3.3.0/exe/jekyll:9:in `&amp;lt;top (required)&amp;gt;'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/jekyll:23:in `load'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/jekyll:23:in `&amp;lt;main&amp;gt;'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/ruby_executable_hooks:15:in `eval'
	from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/ruby_executable_hooks:15:in `&amp;lt;main&amp;gt;'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原因： 没有安装 bundler ，执行安装 bundler 命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$ gem install bundler

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Fetching: bundler-1.13.5.gem (100%)
Successfully installed bundler-1.13.5
Parsing documentation for bundler-1.13.5
Installing ri documentation for bundler-1.13.5
Done installing documentation for bundler after 5 seconds
1 gem installed

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次执行 $ jekyll server  ，提示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Could not find proper version of jekyll (3.1.1) in any of the sources
Run `bundle install` to install missing gems.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;跟着提示运行命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bundle install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候你可能会发现 bundle install 运行卡主不动了。&lt;/p&gt;

&lt;p&gt;如果很长时间都没任何提示的话，你可以尝试修改 gem 的 source&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem sources --remove https://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次执行命令 $ bundle install，发现开始有动静了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Fetching gem metadata from https://rubygems.org/...........
Fetching version metadata from https://rubygems.org/..
Fetching dependency metadata from https://rubygems.org/.
。。。
Installing jekyll-watch 1.3.1
Installing jekyll 3.1.1
Bundle complete! 3 Gemfile dependencies, 17 gems now installed.
Use `bundle show [gemname]` to see where a bundled gem is installed.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bundler安装完成，后再次启动本地服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll server

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;继续报错&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Configuration file: /Users/tendcloud-Caroline/Desktop/leopardpan.github.io/_config.yml
  Dependency Error: Yikes! It looks like you don't have jekyll-sitemap or one of its dependencies installed. In order to use Jekyll as currently configured, you'll need to install this gem. The full error message from Ruby is: 'cannot load such file -- jekyll-sitemap' If you run into trouble, you can find helpful resources at http://jekyllrb.com/help/! 
jekyll 3.1.1 | Error:  jekyll-sitemap

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;表示 当前的 jekyll 版本是 3.1.1 ，无法使用 jekyll-sitemap&lt;/p&gt;

&lt;p&gt;解决方法有两个&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、打开当前目录下的 _config.yml 文件，把 gems: [jekyll-paginate,jekyll-sitemap] 换成 gems: [jekyll-paginate] ，也就是去掉jekyll-sitemap。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、升级 jekyll 版本，我当前的是 jekyll 3.1.2 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改完成后保存配置，再次执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll server

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;提示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Configuration file: /Users/baixinpan/Desktop/OpenSource/Mine/Page-Blog/leopardpan.github.io-github/_config.yml
            Source: /Users/baixinpan/Desktop/OpenSource/Mine/Page-Blog/leopardpan.github.io-github
       Destination: /Users/baixinpan/Desktop/OpenSource/Mine/Page-Blog/leopardpan.github.io-github/_site
 Incremental build: disabled. Enable with --incremental
      Generating... 
                    done in 0.901 seconds.
 Auto-regeneration: enabled for '/Users/baixinpan/Desktop/OpenSource/Mine/Page-Blog/leopardpan.github.io-github'
Configuration file: /Users/baixinpan/Desktop/OpenSource/Mine/Page-Blog/leopardpan.github.io-github/_config.yml
    Server address: http://127.0.0.1:4000/
  Server running... press ctrl-c to stop.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表示本地服务部署成功。&lt;/p&gt;

&lt;p&gt;在浏览器输入 &lt;a href=&quot;127.0.0.1:4000&quot;&gt;127.0.0.1:4000&lt;/a&gt; ， 就可以看到&lt;a href=&quot;http://baixin.io&quot;&gt;baixin.io&lt;/a&gt;博客效果了。&lt;/p&gt;

&lt;h3 id=&quot;修改成你自己的博客&quot;&gt;修改成你自己的博客&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;如果你想使用我的模板请把 _posts/ 目录下的文章都去掉。&lt;/li&gt;
    &lt;li&gt;修改 _config.yml 文件里面的内容为你自己的。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后使用 git push 到你自己的仓库里面去，检查你远端仓库，在浏览器输入 username.github.io 就会发现，你有一个漂亮的主题模板了。&lt;/p&gt;

&lt;h4 id=&quot;-如果想修改博客样式却不知道怎么修改可以直接在评论里给我提问-&quot;&gt;【 如果想修改博客样式却不知道怎么修改，可以直接在评论里给我提问 】&lt;/h4&gt;

&lt;h3 id=&quot;为什么要是用-jekyll&quot;&gt;为什么要是用 Jekyll&lt;/h3&gt;

&lt;p&gt;使用了 Jekyll 你会发现如果你想使用多台电脑发博客都很方便，只要把远端 github 仓库里的博客 clone 下来，写文章后再提交就可以了，Hexo 由于远端提交的是静态网页，所有无法直接写 Markdown 的文章。如果你想看 Hexo 搭建博客，可以看看我的另一篇&lt;a href=&quot;http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;HEXO搭建个人博客&lt;/a&gt;的教程。&lt;/p&gt;

&lt;p&gt;如果你在搭建博客遇到问题，可以在&lt;a href=&quot;http://baixin.io/2016/10/jekyll_tutorials1/&quot;&gt;原文博客&lt;/a&gt;的评论里给我提问。&lt;/p&gt;

&lt;p&gt;后面会继续介绍，在我的博客基础上，如何修改成你自己喜欢的 Style，欢迎继续关注我博客的更新。&lt;/p&gt;

&lt;h3 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题：最近很多朋友使用我的模板报警告：The CNAME &lt;code class=&quot;highlighter-rouge&quot;&gt;baixin.io&lt;/code&gt; is already taken 
解决：把CNAME里面的baixin.io修改成你自己的域名，如果你暂时没有域名，CNAME里面就什么都不用谢。（之前没人反馈过这个问题，应该是github page最近才最的限制。）&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 14 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/10/jekyll_tutorials1/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/10/jekyll_tutorials1/</guid>
        
        <category>博客</category>
        
        
      </item>
    
      <item>
        <title>Git教程</title>
        <description>&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;

&lt;p&gt;　　Git是做项目的版本管理，你也可以称它们为版本管理工具。假如现在你有一个文件夹，里面可以是项目，也可以是你的个人笔记(如我这个博客)，或者是你的简历、毕业设计等等，都可以使用git来管理。&lt;/p&gt;

&lt;p&gt;　　目前常用的版本控制器有Git和SVN，即使这两个你没有全用过，至少也会听过，我这里以Git为例，个人比较喜欢Git，你也可以看看这篇文章：&lt;a href=&quot;http://www.worldhello.net/2012/04/12/why-git-is-better-than-svn.html&quot;&gt;为什么Git比SVN好&lt;/a&gt;。我使用的是Mac，Mac上没自带Git环境，但是作为iOS开发者，我安装Xcode的时候，Xcode里是有自带Git的，所以我不需要考虑怎么去安装Git了。&lt;/p&gt;

&lt;h3 id=&quot;安装git&quot;&gt;安装Git&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;在Mac OS X上安装Git&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提供两种方法参考：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、通过homebrew安装Git，具体方法请参考&lt;a href=&quot;http://brew.sh/&quot;&gt;homebrew的文档&lt;/a&gt;    &lt;br /&gt;
2、直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;在Windows上安装Git&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从&lt;a href=&quot;https://git-for-windows.github.io&quot;&gt;https://git-for-windows.github.io&lt;/a&gt; 下载，然后按默认选项安装即可，安装完成后，在开始菜单里找到“Git”-&amp;gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;配置git&quot;&gt;配置Git&lt;/h3&gt;

&lt;p&gt;安装完成后，还需要最后一步设置，在命令行输入：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;$ git config –global user.name “Your Name”&lt;/li&gt;
    &lt;li&gt;$ git config –global user.email “email@example.com”&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Your Name”： 是每次提交时所显示的用户名，因为Git是分布式版本控制系统，当我们push到远端时，就需要区分每个提交记录具体是谁提交的，这个”Your Name”就是最好的区分。&lt;/p&gt;

&lt;p&gt;“email@example.com”： 是你远端仓库的email&lt;/p&gt;

&lt;p&gt;–global：用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然我们也可以对某个仓库指定不同的用户名和Email地址。&lt;/p&gt;

&lt;h3 id=&quot;开始使用-建立仓库&quot;&gt;开始使用-建立仓库：&lt;/h3&gt;

&lt;p&gt;你在目标文件夹下使命令：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;git init  （创建.git文件）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;就会创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 隐藏文件，相当于已经建立了一个本地仓库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;添加到暂存区：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;git add .   （全部添加到暂存区）&lt;/li&gt;
    &lt;li&gt;git commit -m ‘ first commit’  （提交暂存区的记录到本地仓库）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;

&lt;p&gt;git branc 查看时如出现&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;(HEAD detached at analytics_v2)&lt;/li&gt;
    &lt;li&gt;dev&lt;/li&gt;
    &lt;li&gt;master&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;代表现在已经进入一个临时的HEAD，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b temp&lt;/code&gt; 创建一个 temp branch，这样临时HEAD上修改的东西就不会被丢掉了。
然后切换到 dev 分支上，在使用 git branch merge temp，就可以把 temp 分支上的代码合并到 dev 上了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/07/GitTutorial/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 13 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/07/GitTutorial/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/07/GitTutorial/</guid>
        
        <category>工具</category>
        
        
      </item>
    
  </channel>
</rss>
